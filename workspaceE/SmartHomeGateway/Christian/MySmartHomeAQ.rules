var boolean adaptation_required_gf
var boolean adaptation_required_ff
import java.util.Random
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Calendar
import java.text.DateFormat
val Random random = new Random()
//support variables for dates
var String currentHour
var String currentMinute
var String startingClosingTime
var String stoppingClosingTime
var String startingSystemActivationTime
var String stoppingSystemActivationTime
var String currentDay
var Date startingClosingDate
var Date stoppingClosingDate
var Date startingActivationDate
var Date stoppingActivationDate
var Date currentDate
var DateFormat datos
var int forza //1=apertura 2=chiusura 0=nulla

rule "StartLoop_MySmartHomeAQ"
when
	System started or 
	Item start_m_gf received command ON and              //quando l'utente attua un cambiamento delle date di chiusura/apertura il sistema si riavvia
	Item Starting_Hour_Windows_Closing changed or
    Item Starting_Minute_Windows_Closing changed or
    Item Stopping_Hour_Windows_Closing changed or
    Item Stopping_Minute_Windows_Closing changed or
    Item Starting_Hour_System_Activation changed or
    Item Starting_Minute_System_Activation changed or
    Item Stopping_Hour_System_Activation changed or
    Item Stopping_Minute_System_Activation changed or     
	
then
	if (stoppingClosingDate.before(startingClosingDate)){
        Stopping_Hour_Windows_Closing.state = Starting_Hour_Windows_Closing.state
        Stopping_Minute_Windows_Closing.state = Starting_Minute_Windows_Closing.state
    }
    if (stoppingActivationDate.before(startingActivationDate)){
        Stopping_Hour_System_Activation.state = Starting_Hour_System_Activation.state
        Stopping_Minute_System_Activation.state = Starting_Minute_System_Activation.state
    }
    if (startingActivationDate.after(startingClosingDate) && startingActivationDate.before(stoppingClosingDate)){
        Starting_Hour_System_Activation.state = Stopping_Hour_Windows_Closing.state
        Starting_Minute_System_Activation.state = Stopping_Minute_Windows_Closing.state
    }
    if (stoppingActivationDate.after(startingClosingDate) && stoppingActivationDate.before(stoppingClosingDate)){
        Stopping_Hour_System_Activation.state = Starting_Hour_Windows_Closing.state
        Stopping_Minute_System_Activation.state = Starting_Minute_Windows_Closing.state
    }
    if (startingClosingDate.after(startingActivationDate) && startingClosingDate.before(stoppingActivationDate)){
        Starting_Hour_Windows_Closing.state = Stopping_Hour_System_Activation.state
        Starting_Minute_Windows_Closing.state = Stopping_Minute_System_Activation.state
    }
    if (stoppingClosingDate.after(startingActivationDate) && stoppingClosingDate.before(stoppingActivationDate)){
        Stopping_Hour_Windows_Closing.state = Starting_Hour_System_Activation.state
        Stopping_Minute_Windows_Closing.state = Starting_Minute_System_Activation.state
    }   //controlli per vedere se l'utente ha sbagliato a inserire gli orari di chiusura e apertura delle finestre

	start_a_AQ.sendCommand(OFF)
	start_p_AQ.sendCommand(OFF)
	start_m_gf.sendCommand(ON)
	start_e_gf.sendCommand(OFF)
	start_m_ff.sendCommand(ON)
	start_e_ff.sendCommand(OFF)
	adaptation_required_ff = false
	adaptation_required_gf = false
	if (Managing_System_Active.state == ON) Managing_System_Active.postUpdate(OFF)
end

//-------------------------------------------------------------------------
rule "Monitor_m_gf"
when
	Item start_m_gf received command ON or
    Time cron "0/30 0/1 * 1/1 * ? *" //ogni 30 secondi attua il controllo di monitoring (change to "0 0/1 * * * ?" to fire every minute) 
then
	sendCommand(start_m_gf, OFF)
	//prendiamo l'orario corrente e salviamolo per i confronti che svolgeremo nell'analysis
	datos = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss")
    currentDate = new Date()
    currentDay = Calendar.getInstance().get(Calendar.YEAR).toString() + "-" + (Calendar.getInstance().get(Calendar.MONTH)+1).toString() + "-" + Calendar.getInstance().get(Calendar.DAY_OF_MONTH).toString()
    startingClosingTime = currentDay + " " + Starting_Hour_Windows_Closing.state.toString + ":" + Starting_Minute_Windows_Closing.state.toString + ":00"
    stoppingClosingTime = currentDay + " " + Stopping_Hour_Windows_Closing.state.toString + ":" + Stopping_Minute_Windows_Closing.state.toString + ":00"
    startingSystemActivationTime = currentDay + " " + Starting_Hour_System_Activation.state.toString + ":" + Starting_Minute_System_Activation.state.toString + ":00"
    stoppingSystemActivationTime = currentDay + " " + Stopping_Hour_System_Activation.state.toString + ":" + Stopping_Minute_System_Activation.state.toString + ":00"
    startingClosingDate = datos.parse(startingClosingTime)
    stoppingClosingDate = datos.parse(stoppingClosingTime)
    startingActivationDate = datos.parse(startingSystemActivationTime)
    stoppingActivationDate = datos.parse(stoppingSystemActivationTime)        //tutto questo serve per inserire in queste ultime variabili le date di start e di stop del sistema
	sendCommand(gf_slave_to_aq_master, ON)

end
//&&&&&&&&&&&&&&&&&
rule "Monitor_m_ff"
when
	Item start_m_ff received command ON and
	Time cron "0/30 0/1 * 1/1 * ? *" //ogni 30 secondi attua il controllo di monitoring (change to "0 0/1 * * * ?" to fire every minute) 
then
	sendCommand(start_m_ff, OFF)
	//prendiamo l'orario corrente e salviamolo per i confronti che svolgeremo nell'analysis
	datos = new SimpleDateFormat ("yyyy-MM-dd HH:mm:ss")
    currentDate = new Date()
    currentDay = Calendar.getInstance().get(Calendar.YEAR).toString() + "-" + (Calendar.getInstance().get(Calendar.MONTH)+1).toString() + "-" + Calendar.getInstance().get(Calendar.DAY_OF_MONTH).toString()
    startingClosingTime = currentDay + " " + Starting_Hour_Windows_Closing.state.toString + ":" + Starting_Minute_Windows_Closing.state.toString + ":00"
    stoppingClosingTime = currentDay + " " + Stopping_Hour_Windows_Closing.state.toString + ":" + Stopping_Minute_Windows_Closing.state.toString + ":00"
    startingSystemActivationTime = currentDay + " " + Starting_Hour_System_Activation.state.toString + ":" + Starting_Minute_System_Activation.state.toString + ":00"
    stoppingSystemActivationTime = currentDay + " " + Stopping_Hour_System_Activation.state.toString + ":" + Stopping_Minute_System_Activation.state.toString + ":00"
    startingClosingDate = datos.parse(startingClosingTime)
    stoppingClosingDate = datos.parse(stoppingClosingTime)
    startingActivationDate = datos.parse(startingSystemActivationTime)
    stoppingActivationDate = datos.parse(stoppingSystemActivationTime)        //tutto questo serve per inserire in queste ultime variabili le date di start e di stop del sistema
	sendCommand(ff_slave_to_aq_master, ON)
end

rule "Aggregator_m_gf_m_ff_a_AQ"
when
	Item gf_slaveff_slave_to_aq_master received update ON
then
	sendCommand(gf_slave_to_aq_master, OFF)
	sendCommand(ff_slave_to_aq_master, OFF)
	sendCommand(start_a_AQ, ON)
end

//-------------------------------------------------------------------------
rule "Analyze_a_AQ"      //faccio solo per la forzatura
when
	Item start_a_AQ received command ON
then
	sendCommand(start_a_AQ, OFF)

	//vediamo di analizzare in che fascia oraria siamo, se ad esempio siamo in quella di
	if ((currentDate.after(startingClosingDate) && currentDate.before(stoppingClosingDate))){
		forza=2  //chiudere
		sendCommand(start_p_AQ, ON)
	}

	if (currentDate.after(startingActivationDate) && currentDate.before(stoppingActivationDate)){
		forza=1  //aprire
		sendCommand(start_p_AQ, ON)
	}
//-----------&&&&&&&&&&&---------- qui devo fare i controlli della qualità dell'aria
	if (forza==0){
		if(cbQuality>=                                ){
			adaptation_required_a_AQ = true
		}
		else {
			adaptation_required_a_AQ = false
		}
		if(adaptation_required_a_AQ){
			sendCommand(start_p_AQ, ON)
		}
		//uscita senza necessità di adattarsi
		else{
			sendCommand(start_m_gf, ON)
			sendCommand(start_m_ff, ON)
		}
	}
end

rule "Plan_p_AQ"
when
	Item start_p_AQ received command ON
then
if (forza==1 or forza==2){
	sendCommand(start_p_AQ, OFF)
	sendCommand(start_e_ff, ON)
	sendCommand(start_e_gf, ON)
}
//altrimenti fai il planning normale
else{    



	sendCommand(start_p_AQ, OFF)
	sendCommand(start_e_gf, ON)
	sendCommand(start_e_ff, ON)
}
end

rule "Exec_e_gf"
when
	Item start_e_gf received command ON
then
	if (forza==1){
		GF_Living_Window.postUpdate("OPEN")
    	GF_Kitchen_Window.postUpdate("OPEN")
    	GF_Bathroom_Window.postUpdate("OPEN")
	}
	if(forza==2){
		GF_Living_Window.postUpdate("CLOSED")
        GF_Kitchen_Window.postUpdate("CLOSED")
        GF_Bathroom_Window.postUpdate("CLOSED")
	}




	sendCommand(start_e_gf, OFF)
	sendCommand(start_m_gf, ON)
end

rule "Exec_e_ff"
when
	Item start_e_ff received command ON
then
	if (forza==1){
		FF_Bedroom_Window.postUpdate("OPEN")
    	FF_ChildrenRoom_Window.postUpdate("OPEN")
	}
	if(forza==2){
		FF_Bedroom_Window.postUpdate("CLOSED")
        FF_ChildrenRoom_Window.postUpdate("CLOSED")
	}



	sendCommand(start_e_ff, OFF)
	sendCommand(start_m_ff, ON)
end

